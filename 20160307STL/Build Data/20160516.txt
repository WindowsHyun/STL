
---------------------------------------
2016년 1학기 STL
Mon May 16 10:57:48 2016
---------------------------------------

//---------------------------------------------------------------------------
// 2016년 05월 16일
//
// 다음 주 수(5.18) 퀴즈 2 예정
//---------------------------------------------------------------------------
#include <iostream>
#include<unordered_set>
#include "save.h"

using namespace std;
/*
 컨테이너 기능 - 306쪽
 1. 모든 컨테이너는 값 문맥을 제공한다
 2. 내부 원소는 특정 순서대로 저장된다.
 3. 모든 연산은 일반적으로 오류를 검사하지 않는다.
*/
int main() {
	unordered_set<int> u{ 1, 2, 3, 4, 5 };

	for ( int i = 0; i < 10; ++i ) {
		for ( int d : u )
			cout << d << " ";
		cout << endl;
		u.insert( 6+i );
	}
	save();
}
---------------------------------------
2016년 1학기 STL
Mon May 16 11:01:18 2016
---------------------------------------

//---------------------------------------------------------------------------
// 2016년 05월 16일
//
// 다음 주 수(5.18) 퀴즈 2 예정
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <string>
#include "save.h"

using namespace std;
/*
 컨테이너 기능 - 306쪽
 1. 모든 컨테이너는 값 문맥을 제공한다
 2. 내부 원소는 특정 순서대로 저장된다.
 3. 모든 연산은 일반적으로 오류를 검사하지 않는다.
*/
int main() {
	/*
	한문장을 이용해서
	입력받은 단어를 오름차순으로 정렬하시오.
	*/
	vector<int> s{ 1, 2, 3, 4, 5 };

	vector<int> v( s.rbegin(), s.rend() );

	for ( int d : v )
		cout << d << endl;

	save();

	//save();
}
---------------------------------------
2016년 1학기 STL
Mon May 16 11:02:36 2016
---------------------------------------

//---------------------------------------------------------------------------
// 2016년 05월 16일
//
// 다음 주 수(5.18) 퀴즈 2 예정
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <fstream>
#include <iterator>
#include <string>
#include "save.h"

using namespace std;
/*
 컨테이너 기능 - 306쪽
 1. 모든 컨테이너는 값 문맥을 제공한다
 2. 내부 원소는 특정 순서대로 저장된다.
 3. 모든 연산은 일반적으로 오류를 검사하지 않는다.
*/
int main() {
	/*
	한문장을 이용해서
	입력받은 단어를 오름차순으로 정렬하시오.
	*/
	string s;
	ifstream in( "소스.cpp" );
	int n{ 0 };
	while ( in >> s ) {
		// 한 단어 읽음 s 에다가
		copy( s.rbegin(), s.rend(), ostream_iterator<char>( cout, "" ) );
		cout << endl;
		n++;
		//cout << s << endl;
	}
	cout << "몇개 인가 : " << n << endl;
	save();

	//save();
}
---------------------------------------
2016년 1학기 STL
Mon May 16 11:04:22 2016
---------------------------------------

//---------------------------------------------------------------------------
// 2016년 05월 16일
//
// 다음 주 수(5.18) 퀴즈 2 예정
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <fstream>
#include <iterator>
#include <string>
#include "save.h"

using namespace std;
/*
 컨테이너 기능 - 306쪽
 1. 모든 컨테이너는 값 문맥을 제공한다
 2. 내부 원소는 특정 순서대로 저장된다.
 3. 모든 연산은 일반적으로 오류를 검사하지 않는다.
*/
int main() {
	/*
	한문장을 이용해서
	입력받은 단어를 오름차순으로 정렬하시오.
	*/
	string s;
	ifstream in( "소스.cpp" );
	int n{ 0 };
	while ( in >> s >> s ) {
		// 한 단어 읽음 s 에다가
		copy( s.rbegin(), s.rend(), ostream_iterator<char>( cout, "" ) );
		cout << endl;
		n++;
		//cout << s << endl;
	}
	cout << "몇개 인가 : " << n << endl;
	save();

	//save();
}
---------------------------------------
2016년 1학기 STL
Mon May 16 11:04:36 2016
---------------------------------------

//---------------------------------------------------------------------------
// 2016년 05월 16일
//
// 다음 주 수(5.18) 퀴즈 2 예정
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <fstream>
#include <iterator>
#include <string>
#include "save.h"

using namespace std;
/*
 컨테이너 기능 - 306쪽
 1. 모든 컨테이너는 값 문맥을 제공한다
 2. 내부 원소는 특정 순서대로 저장된다.
 3. 모든 연산은 일반적으로 오류를 검사하지 않는다.
*/
int main() {
	/*
	한문장을 이용해서
	입력받은 단어를 오름차순으로 정렬하시오.
	*/
	string s;
	ifstream in( "소스.cpp" );
	int n{ 0 };
	while ( in >> s ) {
		// 한 단어 읽음 s 에다가
		copy( s.rbegin(), s.rend(), ostream_iterator<char>( cout, "" ) );
		cout << endl;
		n++;
		//cout << s << endl;
	}
	cout << "몇개 인가 : " << n << endl;
	save();

	//save();
}
---------------------------------------
2016년 1학기 STL
Mon May 16 11:11:54 2016
---------------------------------------

//---------------------------------------------------------------------------
// 2016년 05월 16일
//
// 다음 주 수(5.18) 퀴즈 2 예정
//---------------------------------------------------------------------------
#include <iostream>
#include <set>
#include <string>
#include <iterator>
#include "save.h"

using namespace std;
/*
 컨테이너 기능 - 306쪽
 1. 모든 컨테이너는 값 문맥을 제공한다
 2. 내부 원소는 특정 순서대로 저장된다.
 3. 모든 연산은 일반적으로 오류를 검사하지 않는다.
*/
int main() {
	/*
	한문장을 이용해서
	입력받은 단어를 오름차순으로 정렬하시오.
	*/
	multiset<string> s{ istream_iterator<string>( cin ), istream_iterator<string>() };

	for ( string d : s )
		cout << d << " ";
	cout << endl;
	save();
}
---------------------------------------
2016년 1학기 STL
Mon May 16 11:29:52 2016
---------------------------------------

//---------------------------------------------------------------------------
// 2016년 05월 16일
//
// 다음 주 수(5.18) 퀴즈 2 예정
//---------------------------------------------------------------------------
#include <iostream>
#include <set>
#include "save.h"

using namespace std;
/*
 컨테이너 기능 - 306쪽
 1. 모든 컨테이너는 값 문맥을 제공한다
 2. 내부 원소는 특정 순서대로 저장된다.
 3. 모든 연산은 일반적으로 오류를 검사하지 않는다.
*/
int main() {
	multiset<int> s{ 1, 1, 1, 2, 3, 4 ,6, 6, 7 };
	auto p = find( s.begin(), s.end(), 2 );
	
	for ( int i = 0; i < 10, p != s.begin(); ++i ) {
		--p;
	}
	cout << *p << endl;
	save();
}
---------------------------------------
2016년 1학기 STL
Mon May 16 12:15:45 2016
---------------------------------------

//---------------------------------------------------------------------------
// 2016년 05월 16일
//
// 다음 주 수(5.18) 퀴즈 2 예정
//---------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"

using namespace std;
/*
 컨테이너 기능 - 306쪽
 1. 모든 컨테이너는 값 문맥을 제공한다
 2. 내부 원소는 특정 순서대로 저장된다.
 3. 모든 연산은 일반적으로 오류를 검사하지 않는다.
*/

class Game {
	int n;
public:
	Game( int n ) : n( n ) {}
	operator int() {
		return n;
	}
};

int main() {
	vector<Game> v{ 1, 6, 2, 5, 3, 4 };

	auto p = v.begin();
	cout << *p << endl;
	// 반복자 무효화
	v.reserve( 100 );
	// 확장을 하면서 기존 포인터를 지우고 새로운 위치에 포인터가 만들어지면서
	// 기존에 p 위치가 의미가 없어진다.
	p = v.begin();
	// 486쪽
	cout << *p << endl; 
	save();
}